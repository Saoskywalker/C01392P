// F03芯片基本信息(基于F03_数据手册_V1.5版本)
//
// 一、内核
//	 1T 8051内核,内部时钟最高频率16MHz,内部低频16Khz,外部2-20MHz,
//	 支持振荡器停振检测功能，VDD 工作电压范围 2.0~5.5V。
//   最大工作频率说明
//	 工作条件 VDD 最大工作频率（MHz）
//	 芯片运行时钟不分频
//	 1.8~5.5V----2M(最大工作频率)
//	 3.0~5.5V----8M(最大工作频率)
//	 4.5~5.5V---16M(最大工作频率)

//
// 二、存储
//	 16K 字节 MAIN FLASH 程序存储器
//	 128 字节 EEPROM 数据存储器
//	 核内 256 字节 SRAM，核外 768 字节SRAM
//
// 三、复 位
//  内置上电复位 POR
//  内置掉电复位 BOR,支持8 档掉电复位1.6V~4.4V，步进0.4V
//  支持外部复位端口RSTN,低电平复位
//
// 四、端口
//	 最多支持30个I/O端口，8 个可复用COM口（COM 端口灌电流最大80mA）,
//	 12 个SEG 复用口支持2,4,8,15mA 模式
//	 所有端口支持独立弱上拉和弱下拉控制,可同时开启上拉和下拉实现1/2 VDD 用于LCD 驱动
//	 所有端口支持外部中断唤醒
//
// 五、外设
//   4路16+3位定时/计数器TMR
//   3路边沿捕捉器CAP
//   3组独立16位脉宽调制器PWM,每组支持2个PWM输出通道
//   24 通道触摸按键TouchKey
//   1路IIC总线控制器
//   2路UART收发器
//   1路SPI收发器
//   内置低电压检测模块LVD
//   12通道12位SAR结构ADC,最高采样率100KHz//其中1 路通道用于VDD 检测，
//   内置多档参考电压，,出厂校准精度<±1.5%
//   8COM x 12SEG LED 驱动


/* Includes ------------------------------------------------------------------*/
#include "GCE_General.h"			//系统 通用调用文件
/* Private defines -----------------------------------------------------------*/
void WatchDog_Init(void);
void Startup_Init(void);
void Priority_Init(void);
void IO_Init(void);
void Timer0_Init(void);
void ADC_Init(void);
void EXT0_Init(void);
void EXT1_Init(void);
void __delay(UI16 _time);
void UART0_Init(void);
void UART1_Init(void);
void PWM0_Init(void);
void PWM1_Init(void);
void MCU_Initial(void);
void LVD_Init(void);
/*****************************************************************************
/*************************************************
//名称        :WatchDog_Init
//功能        :Watchdog配置, 不同的芯片此程序不同
//入口参数    :无
//出口参数    :无
//当前版本    :V0.0
//编写:       :周智伟
//审核        :刘磊
//审核日期    :2021.5.13
//修改记录    :2021.5.14  V0.0初版发布
************************************************/
#if(!GCE_DEBUG)
void WatchDog_Init(void)
{
//WDT_C WDT控制寄存器
//Bit7-6 保留
//Bit5 WDT_PD:软件WDT 关断位（仅在配置字关闭后生效）
//1 ：关闭WDT  //0 ：使能WDT
//Bit4 WDT_CKS：WDT 时钟源选择位
//1：内部低频时钟LRC//0：系统时钟SYS_CLK
//Bit3-0 WDT_CYC <3:0>：WDT 溢出周期寄存器(下表时间为LRC 工作时时间)
//0000：2560ms 0001：2000ms 0010：1500ms 0011：1000ms
//0100： 900ms 0101：800ms  0110： 700ms 0111：600ms
//1000： 500ms 1001：400ms  1010： 300ms 1011：200ms
//1100： 100ms 1101： 60ms  1110： 30ms  1111： 20ms
	WDT_C=_0001_0000|WDT_TIME_VALUE;//使能WDT//内部低频时钟LRC(规格书精度为+/-3%)
}
#endif
//////////////////////////////////////////////////////////////////////////
#if(GCE_PRIORITY_EN)
/*************************************************
//名称        :MCU_priority_config
//功能        :中断优先级配置
//入口参数    :无
//出口参数    :无
//当前版本    :V0.0
//编写:       :周智伟
//审核        :刘磊
//审核日期    :2021.5.13
//修改记录    :2021.5.14  V0.0初版发布
************************************************/
void Priority_Init(void)
{
    //----<< 中断向量表 >>----
    //--------------------------------------------------------------------------------------------------------
	// 向量编号  | Interrupt | 入口地址 | 向量使能    | 向量标志  | 中断源使能     | 中断源标志    |
	// INT0     |	0 	    | 0003H    | INT0_IE  | INT0_IF  | EINTn_IE(n=7:0) | EINTn_IF(n=7:0)   |
   	// INT1 	|	2 	    | 0013H    | INT1_IE  | INT1_IF  | EINTn_IE(n=7:0) | EINTn_IF(n=7:0)   |
   	// INT2 	|	7 	    | 003BH    | INT2_IE  | INT2_IF  | TMRn_IE TMRn_IF |                   |
   	//			|		    |		   | 		  |          | CAPn_IE         | CAPn_IF           |
   	//			|		    |		   | 		  |          | PWMn_IE         | PWMn_IF           |
   	//			|		    |		   | 		  |          | STPn_IE         | STP_IF<2:0>       |
   	//--------------------------------------------------------------------------------------------------------
   	// INT3 	|	8 	    | 0043H    | INT3_IE  | INT3_IF  | TX_IE 		   | TX_IF             |
   	//			|		    |		   | 		  |     	 | RX_IE           | RX_IF             |
   	//			|		    |          |          |          | IIC_IE          | IIC_IF            |
   	//          |           |          |          |          | SPI_IE          | SPI_IF            |
   	//--------------------------------------------------------------------------------------------------------
   	// INT4     |   9       | 004BH    | INT4_IE  | INT4_IF  | TK_IE           | TK_IF             |
   	// INT5     |   10      | 0053H    | INT5_IE  | INT5_IF  | ADC_IE          | ADC_IF            |
   	// INT6     |   11      | 005BH    | INT6_IE  | INT6_IF  | LVD_IE          | LVD_IF            |
   	//                                                       | LED_IE          | LED_IF            |
   	//                                                       | COM_IE          | COM_IF            |
    //--------------------------------------------------------------------------------------------------------
//中断系统分为2 个优先级阶，即高阶优先级和低阶优先级
//每个中断向量可单独设置优先级阶
//高优先级的中断可嵌套低优先级中断
//嵌套的风险
//在同阶优先级中，中断向量号越小的中断向量优先级越高
//同一中断向量对应的多个中断源不分优先级，用户需在对应于该向量入口地址的中断服务程序中迕行软件判别
//INTn_IP 中断向量优先级寄存器
//Bit7 保留
//Bit6-0 INTn_IP：中断向量INT0~6 优先级选择位
//1：高阶优先级//0：低阶优先级
	INTn_IP=_0000_0001;//外中断0高优先级
}
#endif///GCE_PRIORITY_EN
//////////////////////////////////////////////////////////////////////////
/*************************************************
//名称        :__delay
//功能        :软件延时(限制使用)
//入口参数    :q
//出口参数    :无
//当前版本    :V0.0
//编写:       :周智伟
//审核        :刘磊
//审核日期    :2021.5.11
//修改记录    :2021.5.12  V0.0初版发布
************************************************/
void __delay(UI16 _time)//(限制使用)
{
	while(_time)
  	{_time--;}
}

/*************************************************
//名称        :Startup_Init
//功能        :MCU上电运行初始化
//入口参数    :无
//出口参数    :无
//当前版本    :V0.0
//编写:       :周智伟
//审核        :刘磊
//审核日期    :2021.5.11
//修改记录    :2021.5.12  V0.0初版发布
************************************************/
void Startup_Init(void)
{
	//RST_FLAG 复位标志寄存器
//Bit4 ROM_OV：程序溢出复位标志位
//1：程序执行溢出产生芯片复位//0：未发生程序执行溢出
//Bit3 保留
//Bit2 SRST_F：软件复位标志位
//1：通过写SOFT_RST 寄存器产生软件复位//0：未生软件复位
//Bit1 WDTR_F：WDT 复位标志位
//1：WDT 溢出产生复位//0：未发生WDT 溢出复位
//Bit0 POR_F：POR 上电复位标志位
//1：生POR 上电复位（系统初次上电或系统电源的异常跌落恢复产生的重新上电）
//0：未生POR 上电复位
	SYS_RST_FLAG = 0x08;//清系统复位标志

	_TEST_POWERUP_DELAY
	__delay(5000);    //等待系统上电稳定
	_TEST_POWERUP_DELAY

	SYSCK_DIV2;//系统时钟为2分频
	WKUP_T_8US;	      //8us 唤醒cpu
}

/*************************************************
//名称        :IO_init
//功能        :初始化输入输出端口
//入口参数    :无
//出口参数    :无
//当前版本    :V0.0
//编写        :周智伟
//审核        :刘磊
//审核日期    :2021.5.11
//修改记录    :2021.5.12  V0.0初版发布
************************************************/

/*************************************************************************************************
硬件连接:
P00-SWING_D  P01-COMP   P02-WATER    P05-UV_POWER
P10-AD_TOIL  P12-NC     P11-NC       P13-DISP_TXD    P14-DISP_RXD  P15-SWING_A P16-SWING_B  P17-SWING_C
P20-TWE      P21-NC     P22-FAN_BACK    P24-FILTER_SW   P26-NC  P27-NC
P30-NC       P31-HUM1   P32-HUM2        P33-PWM    P34-AD_ROOM   P35-AD_HUM  P36-AD_COMP P37-FAN
**************************************************************************************************/
void IO_Init(void)
{
	//共有30个IO端口，分4组为P0,P1,P2,P3
	//默认IO相关寄存器全复位
	//F03, 默认io高阻, 禁止输入输出
	//下面是默认状态及控制方式,使用默认的寄存器可以不初始化(x=0,1,2,3)
	//Px_OE:输出使能寄存器, 1:为输出使能，0:为输出禁止，P0_OE = 0; P1_OE = 0; P2_OE = 0; P3_OE = 0;
	//Px_IE:输入使能寄存器， 1:为输入使能，0:为输入禁止，P0_IE = 0; P1_IE = 0; P2_IE = 0; P3_IE = 0;
	//Px_DAT:端口数据寄存器， 1:为驱动高电平，0:为驱动低电平，P0_DAT = 0; P1_DAT = 0; P2_DAT = 0; P3_DAT = 0;
	//Px_PUE:弱上拉使能寄存器，1:为弱上拉使能，0:为弱上拉关闭，P0_PUE = 0; P1_PUE = 0; P2_PUE = 0; P3_PUE = 0;
	//Px_PDE:弱下拉使能寄存器，1:为弱下拉使能，0:为弱下拉关闭，P0_PDE = 0; P1_PDE = 0; P2_PDE = 0; P3_PDE = 0;
	//Px_ODE:开漏使能寄存器， 1:为开漏输出模式，0:为推挽输出模式， P0_ODE = 0; P1_ODE = 0; P2_ODE = 0; P3_ODE = 0;
	//Px_SMITE:施密特功能使能寄存器，1:为施密特功能使能，0:为施密特功能禁止， P0_SMITE=0; P1_SMITE=0; P2_SMITE=0; P3_SMITE=0;
///////////////////////////////////////////////////////////////////////////
	//设置为推挽输出时, F03默认推挽输出, 低电平, 15mA高电平驱动电流
	//配置为ADC模拟功能的管脚，需设置为模拟通道， 关闭管脚输入输出功能
//////////////////////////////////////////////////////////////////////////
	//全端口控制寄存器:PORT_C0
	//使用BIT3:BIT2
	//11和00===输出模式时读端口寄存器，输入模式时读端口电平
	//10===始终读端口寄存器，01始终读端口电平
	PORT_C0=_0000_0000;//始终读端口寄存器//禁止修改
//////////////////////////////////////////////////////////////////////////
	//P0端口设置开始
	//当前有的端口P00 P01 P02 P03 P04 P05
	//P0弱上拉使能
	P0_PUE=_0000_0001;//P00弱上拉输入
	//P0弱下拉使能
	P0_PDE=_0000_0010;//P01弱下拉输入
	//P0开漏输出使能
	P0_ODE=_0000_0000;
	//P0输出电流选择低字节
	//B7:B6--P03端口驱动电设置11==8mA,10==4mA,01==2mA,00==15mA
	//B5:B4--P02端口驱动电设置11==8mA,10==4mA,01==2mA,00==15mA
	//B3:B2--P01端口驱动电设置11==8mA,10==4mA,01==2mA,00==15mA
	//B1:B2--P00端口驱动电设置11==8mA,10==4mA,01==2mA,00==15mA
	P0_IOL_CL=_0000_0000;//
	//P0端口施密特功能使能
	P0_SMITE=_0000_0100;
	//P0输出使能
	P0_OE=_0010_0011;//P02输出
	//P0输入使能
	P0_IE=_1101_1100;//P00,P01,P03,P04输入
    P02_FUN_TIN2;//水满口
	//P01_FUN_RX0;
	//P00_FUN_TX0;
	//P0端口数据寄存器
	P0_DAT=_0000_0000;//P02输出高//P03输出高
	//P0端口设置结束
//////////////////////////////////////////////////////////////////////////
	//P1端口设置开始
	//当前有的端口P10 P11 P12 P13 P14 P15 P16 P17
	//P1弱上拉使能
	P1_PUE=_0000_0000;
	//P1弱下拉使能
	P1_PDE=_0000_0000;
	//P1开漏输出使能
	P1_ODE=_0000_1000;
	//P1输出电流选择低字节
	//B7:B6--P13端口驱动电流设置11==8mA,10==4mA,01==2mA,00==15mA
	//B5:B4--P12端口驱动电流设置11==8mA,10==4mA,01==2mA,00==15mA
	//B3:B2--P11端口驱动电流设置11==8mA,10==4mA,01==2mA,00==15mA
	//B1:B0--P10端口驱动电流设置11==8mA,10==4mA,01==2mA,00==15mA
	P1_IOL_CL=_0000_0000;
	//P1输出电流选择高字节
	//B7:B6--P17端口驱动电流设置11==8mA,10==4mA,01==2mA,00==15mA
	//B5:B4--P16端口驱动电流设置11==8mA,10==4mA,01==2mA,00==15mA
	//B3:B2--P15端口驱动电流设置11==8mA,10==4mA,01==2mA,00==15mA
	//B1:B2--P14端口驱动电流设置11==8mA,10==4mA,01==2mA,00==15mA
	P1_IOL_CH=_0000_0000;
	//P1端口施密特功能使能
	P1_SMITE=_0000_0000;
	//P1输出使能
	P1_OE=_1110_1000;
	//P1输入使能
	P1_IE=_0001_0110;
	//P1端口数据寄存器
	P1_DAT=_0000_1000;//TX空闲电平为高
    P14_FUN_TIN2;
	//P1端口设置结束
//////////////////////////////////////////////////////////////////////////
	//P2端口设置开始
	//当前有的端口P20 P21 P22 P23 P24 P25 P26 P27
	//P0弱上拉使能
	P2_PUE=_0000_0001;
	//P0弱下拉使能
	P2_PDE=_0000_0000;
	//P0开漏输出使能
	P2_ODE=_0000_0010;
	//P0端口施密特功能使能
	//P2_SMITE=_0000_0000;
	//P2端口数据寄存器
	//P2_DAT=_0000_0000;
	//P2输出使能
	P2_OE=_0000_0100;//P22输出//P23输出
	//P2输入使能
	P2_IE=_1111_1011;///SWE//P20端口设置必须为输入,否则调试异常
        //P2端口施密特功能使能
	P2_SMITE=_0000_0000;
	//P24_FUN_PWM00;
	//P1端口数据寄存器
	P2_DAT=_0000_0000;
	//P2端口设置结束
//////////////////////////////////////////////////////////////////////////
	//P3端口设置开始
	//当前有的端口P30 P31 P32 P33 P34 P35 P36 P37
	//P3弱上拉使能
	P3_PUE=_0000_0000;
	//P3弱下拉使能
	P3_PDE=_0000_0000;
	//P3开漏输出使能
	P3_ODE=_0000_0110;
	//P3输出电流选择低字节
	//B7:B6--P33端口驱动电流设置01==80mA,00==15mA
	//B5:B4--P32端口驱动电流设置01==80mA,00==15mA
	//B3:B2--P31端口驱动电流设置01==80mA,00==15mA
	//B1:B2--P30端口驱动电流设置01==80mA,00==15mA
	P3_IOL_CL=_0100_0000;///P30=80mA
	//P3输出电流选择高字节
	//B7:B6--P37端口驱动电流设置01==80mA,00==15mA
	//B5:B4--P36端口驱动电流设置01==80mA,00==15mA
	//B3:B2--P35端口驱动电流设置01==80mA,00==15mA
	//B1:B2--P34端口驱动电流设置01==80mA,00==15mA
	P3_IOL_CH=_0000_0000;///
	//P3端口施密特功能使能
	P3_SMITE=_0000_0110;
	//P3输出使能
	P3_OE=_1000_1110;
	//P3输入使能
	P3_IE=_0000_0000;
	//P33_FUN_PWM01;
	//P3端口数据寄存器
	P3_DAT=_0000_0110;
	//P3端口设置结束
	////////////////////////////////////////////////////////////
	//复用功能必须在配置完IO端口后再配置
	//ADC模拟功能的管脚，需设置为模拟通道， 关闭管脚输入输出功能
	//外中断 IO在外中断初始化上配置
	//UART IO在UART初始化上配置

}
/*************************************************
//名称        :Timer0_init
//功能        :定时器1mS初始化
//入口参数    :无
//出口参数    :无
//当前版本    :V0.0
//编写:       :周智伟
//审核        :刘磊
//审核日期    :2021.5.11
//修改记录    :2021.5.12  V0.0初版发布
************************************************/
void Timer0_Init(void)
{
//TMRn_C0 TMR0 控制寄存器0
//Bit7 TMRn_EN：TMRn 使能位
// 1：使能 0：关闭
//Bit6 TMRn_PRE：TMRn 计数时钟预 8 分频使能位
// 1：使能 0：关闭
//Bit5-4 TMRn_CKS<3:0>：TMRn 计数时钟选择位
// 11：TMR0 为 XOSC 振荡器,TMR1 为 LRC 10MS 脉冲，TMR2 TMR3 为 LRC 时钟
// 10：HRC 内部高频时钟
// 01：EXCK 复用端口输入
// 00：SYS_CLK 系统时钟源
//Bit3-0 TMRn_PST<3:0>：TMRn 后分频位
// TMRn 的 n 次溢出产生中断（n = TMRn_POS<3:0> + 1）
///////////////////////////////////////////////////////////////
    UI16 time_val = 0;

    TMR0_C0=_0000_0000;       //固定选择系统时钟8M//预分频1分频//后分频1分频
///////////////////////////////////////////
    //time_val = (UI16)((((SYS_CLK_VALUE / 2000) * SYS_TIME_VALUE)  / 1000)-1);
    time_val = (UI16)((((SYS_CLK_VALUE / 1000) * SYS_TIME_VALUE)  / 1000)-1);
    TMR0_CYH = (UI08)(time_val >> 8);
    TMR0_CYL = (UI08)(time_val);
    //TMR计数器低8位 - 初始化为0
    TMR0L = 0;
    TMR0H = 0;
////////////////////////////////////
    TMR0_EN; //开定时器
    TMR0_INT_EN; //使能TMR的中断使能
////////////////////////////////////
    INT2_EN; //中断向量2使能
    //注意中断优先级统一处理函数
}
////////////////////////////////////////////////////////////////////////
#if(GCE_ADC_EN)
/*************************************************
//名称        :ADC_init
//功能        :ADC初始化
//入口参数    :无
//出口参数    :无
//当前版本    :V0.0
//编写:       :周智伟
//审核        :刘磊
//审核日期    :2021.5.12
//修改记录    :2021.5.13  V0.0初版发布
************************************************/
void ADC_Init(void)
{
//VREF_C VREF内部参考电压模块配置寄存器
//EBH：使能内部参考电压//00H：关闭VREF 模块//其他：保留
//////////////////////////////////////////////////////////////
//ADC_C0 ADC 控制寄存器0
//Bit7 ADC_EN：ADC使能位//1：使能//0：关闭
//Bit6 S_TRG：ADC 软件触发位//1：触ADC 转换//0：转换完成（硬件自动清0）
//Bit5-4 TRG_S<1:0>：触发方式选择位
//1x：TMR2 计数值匹配ADC_TR_R0 值后触ADC，再PWM1_R0+ADC_TR_R0 后
//再次触ADC,此处需注意的是整体的周期限制不要溢出。
//01：TMR2 计数值匹配ADC_TR_R0 值后触发ADC
//00：软件触发（S_TRG 触发转换）
//Bit3-0 CH_SEL<3:0>：ADC 采样通道选择位
//其他：所有通道关闭
//1011：选择内部1/4 VDD 通道
//1010：选择通道AN10
//1001：选择通道AN9
//… … …
//0001：选择通道AN1
//0000：选择通道AN0
//////////////////////////////////////////////////////////////
//ADC_C1:ADC控制寄存器1
//ADC_CKS<1:0>：ADC 转换时钟ADC_CLK 选择位
//11：系统时钟SYS_CLK 16 分频
//10：系统时钟SYS_CLK 8 分频
//01：系统时钟SYS_CLK 4 分频
//00：系统时钟SYS_CLK 2 分频
//Bit3 保留
//Bit2 ADC_DM：ADC 转换数据格式选择位
//1：左对齐（结果放置{ADC_DH<7:0>, ADC_DL<7:4>}）
//0：右对齐（结果放置{ADC_DH<3:0>, ADC_DL<7:0>}）
//Bit7-4 VREFP_S<3:0>：VREFP_S ADC 参考选择（使用 VREF 需要先开启 VREF）
// 1111：选择内部 VREF 0.2V 1110：选择内部 VREF 0.5V
// 1101：选择内部 VREF 1.2V 1100：选择内部 VREF 1.5V
// 1011：未用 1010：选择内部 VREF 1.024V
// 1001：选择内部 VREF 2.048V 1000：选择内部 VREF 2.5V
// 0010：选择内部 VDD 0001：ADVP 复用端口输入参考
// 0000：关闭
//////////////////////////////////////////////////////////////
//ADC_C2 ADC 控制寄存器2
//Bit7-6 保留（用户固定写11）
//Bit5-4 ADC_CNT<1:0>：ADC 转换次数选择位
//11：8 次转换取平均
//10：4 次转换取平均
//01：2 次转换取平均
//00：1 次转换
//Bit3 保留
//Bit2-0 SMP_T<2:0>：ADC 采样时间控制位
//采样时间TSAMPLE = （SMP_T<2:0> x 2 + 1） x TADC_CLK
//////////////////////////////////////////////////////////////
//ADC_TG_R0L TMR2 触发ADC 延时值低8 位
//Bit7-0 ADC_TG_R0L<7:0>：TMR2 触ADC 延时值低位
//ADC_TG_R0H TMR2 触发ADC 延时值高8 位
//Bit7-0 ADC_TG_R0H<7:0>：TMR2 触ADC 延时值高位

//////////////////////////////////////////////////////////////
//ADC_CMP_C ADC 比较控制寄存器
//Bit7 ADC_CP_E：ADC 比较功能使能位
//1：使能//0：关闭
//Bit6 MAX_E：上限比较使能位
//1：使能////0：关闭
//Bit5 MIN_E：下限比较使能位
//1：使能//0：关闭
//Bit4 INT_MD：ADC 中断模式（比较模式使能后有效）
//1：转换完成和比较超出上下限产生中断
//0：仅比较超出上下限产生中断
//Bit3 MAX_F：上限比较使能位
//1：小于等亍上限阈值
//0：大于上限阈值
//Bit2 MIN_F：下限比较使能位
//1：大于等亍下限阈值
//0：小于下限阈值
//Bit1-0 ADC_DMD<1:0>：ADC_DH 和ADC_DL 操作对象控制
//00：仅可读出ADC 转换值，对齐方式AD_DM控制
//01：对ADC_DH 和ADC_DL 写操作为配置ADC 上限阈值,低对齐
//10：对ADC_DH 和ADC_DL 写操作为配置ADC 下限阈值,低对齐
//11：仅可读出ADC 转换值，对齐方式AD_DM控制
//////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////
//AN_IE 模拟中断使能寄存器（与TK LVD LED 共用地址）
//Bit7-1 保留
//Bit0 ADC_IE：ADC 中断使能位
//1：使能//0：禁止
//AN_IF 模拟中断标志寄存器（与TK LVD LED 共用地址，支持位操作）
//Bit7-1 保留
//Bit0 ADC_IF：ADC 中断标志位
//1：有ADC 中断请求//0：无ADC 中断请求
//////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////
//转换时间为17 个ADC_CLK 加上SMP_T(默讣设置为4 个ADC_CLK),默认情况下转换为21个ADC_CLK

//////////////////////////////////////////////////////////////
//使用ADC模拟功能的管脚，需在IO_init函数中设置为模拟通道， 关闭管脚输入输出功能
	//AN_IF=0;//上电无中断，可以不初始化
	//AN_IE=0;//上电禁止中断，可以不初始化
	VREF_C=0;//当前版本未使用，关闭VREF 模块   //VREF_C=0xEB;//使能内部参考电压
	ADC_CMP_C0 = 0x00; //未用到，关闭ADC结果比较寄存器
	ADC_C1 = _0010_0011; //统一使用VREF=VDD;右对齐；16分频//TADC_CLK==1uS;
	//转换时间一次:(17(固定)+ADC采样时间)(SMP_T<2:0> x 2 + 1） x TADC_CLK==15个TADC_CLK==42uS;
	ADC_C2 = _1100_1111; //ADC采样时间:15个TADC_CLK
	//ADC_TG_R0H=0;//此处未使用，可以不初始化
	//ADC_TG_R0L=0;//此处未使用，可以不初始化
	ADC_C0 = bit7|bit6|ADC_USE_CHANNEL_FIRST;//ADC使能，选择初始通道,软件触发一次
}
#endif////GCE_ADC_EN////
////////////////////////////////////////////////////////////////////////

#if(GCE_UART0_EN)
/*************************************************
//名称        :UART0_init
//功能        :UART0初始化
//入口参数    :无
//出口参数    :无
//当前版本    :V0.0
//编写:       :周智伟
//审核        :刘磊
//审核日期    :2021.5.12
//修改记录    :2021.5.13  V0.0初版发布
************************************************/
void UART0_Init(void)
{
//UART0_BRL UARTn 波特率寄存器低8 位
//UART0_BRH UARTn 波特率寄存器高8 位
//////////////////////////////////////////////////////////////
//UART0_RXC// UART1接收控制寄存器
//Bit7 FERR：UARTn 接收帧错误标志位
//1：有帧错误//0：无帧错误
//Bit6 OERR：UARTn 接收溢出错误标志位
//1：有溢出错误//0：无溢出错误
//Bit5 PERR：UARTn 接收校验错误标志位（仅在RXEN<1:0>=11 时有效）
//1：有校验错误//0：无校验错误
//Bit4 RX9D：UARTn 接收第9 位数据
//Bit3 PARS：奇偶校验选择位
//1：偶校验//0：奇校验
//Bit2 BRFX：UARTn 波特率自适应使能位
//1：使能//0：关闭
//Bit1-0 RXEN<1:0>：UARTn 接收使能位
//11：使能9 位数据接收（影响奇偶校验标志PERR）
//10：使能9 位数据接收（不影响奇偶校验标志PERR）
//01：使能8 位数据接收（不影响奇偶校验标志PERR）
//00：关闭RX 接收功能
//////////////////////////////////////////////////////////////
//UARTn_TXC UARTn 发送控制寄存器
//Bit7 TXST：UARTn 送状态标志位
//1：UARTn 送未完成//0：UARTn 送已完成
//Bit6 TXBF：UARTn 送缓冲区满标志位
//1：UARTn 送缓冲区满//0：UARTn 送缓冲区空
//Bit5-4 TX9S<1:0>：UARTn 送第9 位数据格式选择位
//11：送数据1
//10：送数据0
//01：送偶校验
//00：送奇校验
//Bit3 STPS：送STOP 位长度选择位
//1：送2 位STOP 位//0：送1 位STOP 位
//Bit2 TXDM：UARTn 送数据格式选择位
//1：9 位数据//0：8 位数据
//Bit1-0 TXEN<1:0>：UARTn 送使能位
//11：使能，送空闲和送寄存器空均产生中断
//10：使能，送空闲产生中断
//01：使能，送寄存器空产生中断
//00：关闭
//////////////////////////////////////////////////////////////
//UARTn_IE UARTn 中断使能寄存器（与IICn_IE，SPIn_IE 寄存器复用）
//Bit3 TX1_IE：UART1 送中断使能位
//1：使能//0：禁止
//Bit2 RX1_IE：UART1 接收中断使能位
//1：使能//0：禁止
//Bit1 TX0_IE：UART0 送中断使能位
//1：使能//0：禁止
//Bit0 RX0_IE：UART0 接收中断使能位
//1：使能//0：禁止
//////////////////////////////////////////////////////////////
//UARTn_IF UARTn 中断标志寄存器（不IICn_IF SPIn_IF 寄存器复用，支持位操作）
//////////////////////////////////////////////////////////////
//////////////////////////////////////////
    UI16 baudrate_val = 0;
//////////////////////////////////////////
    UART0_TXC =_0000_0010; //uart1 8位发送1个停止位
    UART0_RXC = _0000_0001;//uart1 8位接收//无奇偶校验
//////////////////////////////////////////////////////////////
    //UART IO在IO_init初始化上配置
    baudrate_val = ((UI32)SYS_CLK_VALUE / UART0_BAUDRATE_VALUE) - 1; // 设置在mcu_config.h文件
    UART0_BRL = (UI08)(baudrate_val);
    UART0_BRH = (UI08)(baudrate_val >> 8);  // 通讯波特率 = 系统时钟/4 / (UART_BRR + 1)
    TX0_IF=0;    //清发送中断
    RX0_IF=0;    //清接收中断
    //UART1_TX1_INT_EN;//使能UART0_TX中断//启动发送时置位
    UART0_RX0_INT_EN;//使能UART0_RX中断

    INT3_IF = 0;        //清中断向量中断标志
    INT3_IE = 1;        //中断向量3使能
}
#endif/////(GCE_UART1_EN)
#if(GCE_UART1_EN)
/*************************************************
//名称        :UART1_init
//功能        :UART1初始化
//入口参数    :无
//出口参数    :无
//当前版本    :V0.0
//编写:       :周智伟
//审核        :刘磊
//审核日期    :2021.5.12
//修改记录    :2021.5.13  V0.0初版发布
************************************************/
void UART1_Init(void)
{
//UART1_BRL UARTn 波特率寄存器低8 位
//UART1_BRH UARTn 波特率寄存器高8 位
//////////////////////////////////////////////////////////////
//UART1_RXC// UART1接收控制寄存器
//Bit7 FERR：UARTn 接收帧错误标志位
//1：有帧错误//0：无帧错误
//Bit6 OERR：UARTn 接收溢出错误标志位
//1：有溢出错误//0：无溢出错误
//Bit5 PERR：UARTn 接收校验错误标志位（仅在RXEN<1:0>=11 时有效）
//1：有校验错误//0：无校验错误
//Bit4 RX9D：UARTn 接收第9 位数据
//Bit3 PARS：奇偶校验选择位
//1：偶校验//0：奇校验
//Bit2 BRFX：UARTn 波特率自适应使能位
//1：使能//0：关闭
//Bit1-0 RXEN<1:0>：UARTn 接收使能位
//11：使能9 位数据接收（影响奇偶校验标志PERR）
//10：使能9 位数据接收（不影响奇偶校验标志PERR）
//01：使能8 位数据接收（不影响奇偶校验标志PERR）
//00：关闭RX 接收功能
//////////////////////////////////////////////////////////////
//UARTn_TXC UARTn 发送控制寄存器
//Bit7 TXST：UARTn 送状态标志位
//1：UARTn 送未完成//0：UARTn 送已完成
//Bit6 TXBF：UARTn 送缓冲区满标志位
//1：UARTn 送缓冲区满//0：UARTn 送缓冲区空
//Bit5-4 TX9S<1:0>：UARTn 送第9 位数据格式选择位
//11：送数据1
//10：送数据0
//01：送偶校验
//00：送奇校验
//Bit3 STPS：送STOP 位长度选择位
//1：送2 位STOP 位//0：送1 位STOP 位
//Bit2 TXDM：UARTn 送数据格式选择位
//1：9 位数据//0：8 位数据
//Bit1-0 TXEN<1:0>：UARTn 送使能位
//11：使能，送空闲和送寄存器空均产生中断
//10：使能，送空闲产生中断
//01：使能，送寄存器空产生中断
//00：关闭
//////////////////////////////////////////////////////////////
//UARTn_IE UARTn 中断使能寄存器（与IICn_IE，SPIn_IE 寄存器复用）
//Bit3 TX1_IE：UART1 送中断使能位
//1：使能//0：禁止
//Bit2 RX1_IE：UART1 接收中断使能位
//1：使能//0：禁止
//Bit1 TX0_IE：UART0 送中断使能位
//1：使能//0：禁止
//Bit0 RX0_IE：UART0 接收中断使能位
//1：使能//0：禁止
//////////////////////////////////////////////////////////////
//UARTn_IF UARTn 中断标志寄存器（不IICn_IF SPIn_IF 寄存器复用，支持位操作）
//////////////////////////////////////////////////////////////
    UI16 baudrate_val = 0;
//////////////////////////////////////////////////
    UART1_TXC=_0000_0010; //uart1 8位发送1个停止位
    UART1_RXC = _0000_0001;//uart1 8位接收//无奇偶校验
//////////////////////////////////////////////////////////////
    //UART IO在IO_init初始化上配置
    baudrate_val = ((UI32)SYS_CLK_VALUE / UART1_BAUDRATE_VALUE) - 1; // 设置在mcu_config.h文件
    UART1_BRL = (UI08)(baudrate_val);
    UART1_BRH = (UI08)(baudrate_val>> 8);  // 通讯波特率 = 系统时钟/4 / (UART_BRR + 1)

    TX1_IF=0;    //清发送中断
    RX1_IF=0;    //清接收中断
    //UART1_TX1_INT_EN;//使能UART1_TX中断//启动发送时置位
    UART1_RX1_INT_EN;//使能UART1_RX中断

    INT3_IF = 0;        //清中断向量中断标志
    INT3_IE = 1;        //中断向量3使能
}
#endif/////(GCE_UART1_EN)

/////----------------------------------------------
#if(GCE_EXT0_EN)
/*************************************************
//名称        :EXT0_init
//功能        :外中断0初始化
//入口参数    :无
//出口参数    :无
//当前版本    :V0.0
//编写:       :周智伟
//审核        :刘磊
//审核日期    :2021.5.12
//修改记录    :2021.5.13  V0.0初版发布
************************************************/
void EXT0_Init(void)
{
//////////////////////////////////////////////////////////////
//EINT0n_IE EINT使能寄存器
//Bit7-0 EINT0n_IE：外部端口中断0 EINT00~ EINT07 使能位
//1：使能//0：禁止
//////////////////////////////////////////////////////////////
//EINT0n_IF EINT 标志寄存器
//EINT07_IF EINT06_IF EINT05_IF EINT04_IF EINT03_IF EINT02_IF EINT01_IF EINT00_IF
//Bit7-0 EINT0n_IF：外部端口中断0 EINT00~ EINT07 标志位
//1：有EINTn 中断请求//0：无EINTn 中断请求
//////////////////////////////////////////////////////////////
//EINT0n_MD EINT0 触发选择寄存器
//Bit7-0 EINT0_MD：EINTn 触发方式选择位
//1：下降沿触发//0：上升沿触发
//////////////////////////////////////////////////////////////
//DATASHEET是EINT0_SRC实际是EINT0_IOS
//外中断端口选择寄存器
//Bit7//1：P27//0：保留
//Bit6//1：P26//0：保留
//Bit5//1：P25//0：P05
//Bit4//1：P24//0：P04
//Bit3//1：P23//0：P03
//Bit2//1：P22//0：P02
//Bit1//1：P21//0：P01
//Bit0//1：P20//0：P00
	INT0_IF=0;//清INT0中断标志
	//EINT0n_IF=_0000_0000;//清外中断标志
	//EINT0_SRC===EINT0_IOS
	EINT0_IOS=_0000_0000;//P02做外中断源
	EINT0_MD=_0000_0010;//P02上升沿中断
	EINT0_IE=_0000_0100;//P02中断使能
	INT0_IE=1;//INT0中断使能
}
#endif/////(GCE_EXT0_EN)
//////////////////////////////////////////////////////////////
/////----------------------------------------------
#if(GCE_EXT1_EN)
/*************************************************
//名称        :EXT0_init
//功能        :外中断0初始化
//入口参数    :无
//出口参数    :无
//当前版本    :V0.0
//编写:       :周智伟
//审核        :刘磊
//审核日期    :2021.5.12
//修改记录    :2021.5.13  V0.0初版发布
************************************************/
void EXT1_Init(void)
{
//////////////////////////////////////////////////////////////
//EINT1n_IE EINT使能寄存器
//Bit7-0 EINT0n_IE：外部端口中断0 EINT00~ EINT07 使能位
//1：使能//0：禁止
//////////////////////////////////////////////////////////////
//EINT1n_IF EINT 标志寄存器
//EINT17_IF EINT16_IF EINT15_IF EINT14_IF EINT13_IF EINT12_IF EINT11_IF EINT10_IF
//Bit7-0 EINT1n_IF：外部端口中断1 EINT10~ EINT17 标志位
//1：有EINTn 中断请求//0：无EINTn 中断请求
//////////////////////////////////////////////////////////////
//EINT0n_MD EINT0 触发选择寄存器
//Bit7-0 EINT0_MD：EINTn 触发方式选择位
//1：下降沿触发//0：上升沿触发
//////////////////////////////////////////////////////////////
//DATASHEET是EINT0_SRC实际是EINT0_IOS
//外中断端口选择寄存器
//Bit7//1：P37//0：P17
//Bit6//1：P36//0：P16
//Bit5//1：P35//0：P15
//Bit4//1：P34//0：P14
//Bit3//1：P33//0：P13
//Bit2//1：P32//0：P12
//Bit1//1：P31//0：P11
//Bit0//1：P30//0：P10
	INT1_IF=0;//清INT0中断标志
	//EINT0n_IF=_0000_0000;//清外中断标志
	//EINT0_SRC===EINT0_IOS
	EINT1_IOS=_0000_0000;//P14做外中断源
	EINT1_MD=_0001_0000;//P14下降沿中断
	EINT1_IE=_0001_0000;//P14中断使能
	INT1_IE=1;//INT0中断使能
}
#endif/////(GCE_EXT0_EN)
#if(GCE_TIMER1_PWM0_EN)
/*************************************************
//名称        :PWM0_Init
//功能        :PWM0初始化
//入口参数    :无
//出口参数    :无
//当前版本    :V0.0
//编写:       :周智伟
//审核        :刘磊
//审核日期    :2021.5.13
//修改记录    :2021.5.14  V0.0初版发布
************************************************/
void PWM0_Init(void)
{
    UI16 time_val = 0;
//////////////////////////////////////////////////////////////
//PWMn_IE PWM 中断使能寄存器（与CAPn_IE 寄存器复用）
//Bit7 保留,//Bit3 保留
//Bit6-4 STPn_IE：PWMn 刹车中断使能位
//Bit6==STP2_IE.Bit5==STP1_IE.Bit6==STP0_IE
//1：使能//0：禁止
//Bit2-0 PWMn_IE：PWMn 周期中断使能位
//Bit2==PWM2_IE.Bit1==PWM1_IE.Bit0==PWM0_IE
//1：使能//0：禁止
//////////////////////////////////////////////////////////////
//PWMn_IF PWM 中断标志寄存器（不CAPn_IF 寄存器复用）
//Bit7 保留,//Bit3 保留
//Bit6-4 STPn_IF：PWMn 刹车中断标志位
//Bit6==STP2_IF.Bit5==STP1_IF.Bit6==STP0_IF
//1：有PWMn 刹车中断请求//0：无PWMn 刹车中断请求
//Bit2-0 PWMn_IF：PWMn 周期中断标志位
//Bit2==PWM2_IF.Bit1==PWM1_IF.Bit0==PWM0_IF
//1：有PWMn 周期中断请求//0：无PWMn 周期中断请求
//////////////////////////////////////////////////////////////
//PWMn_C PWMn 控制寄存器（与CAPn_C 寄存器复用）
//Bit7-6 PWMn_SPS<1:0>：PWMn 刹车模式选择位（刹车后PWM 模式关闭，需要软件启动，
//清除STP_IF 需要先将 PWMn_SPS 清零，STP_IF 清除完成后，可再次使能对应模式）
//11：软件刹车（写“11”立即迕入刹车状态）
//10：保留
//01：STOP 复用端口输入低电平刹车
//00：关闭刹车功能
//Bit5-4 PWM_MD<1:0>
//11：保留//10：保留
//01：中心对齐模式
//00：边沿对齐模式
//Bit3-2 PWMn_TBS<1:0>：PWMn 工作时基选择位
//11：选择TMR3
//10：选择TMR2
//01：选择TMR1
//00：选择TMR0
//Bit1-0 PWMn_MOD<1:0>：PWMn 模式选择位
//11：保留//10：保留
//01：PWM模式
//00：关闭
//////////////////////////////////////////////////////////////
//PWMn_R0L PWMn 匹配点寄存器低8 位（与CAPn_DL 寄存器复用）写入先高后低
//PWMn_R0H PWMn 匹配点寄存器高8 位（与CAPn_DH 寄存器复用）
//PWMn_R1L PWMn 匹配点寄存器低8 位, 写入先高后低
//PWMn_R1H PWMn 匹配点寄存器高8 位
//////////////////////////////////////////////////////////////
//PWMn_OC PWMn 输出控制寄存器
//Bit7 保留
//Bit6-4 PWMn_REX：PWMn 平均占空比扩展位
//Bit3 PWMn1_T：PWMn 通道 1 输出初始态选择位
//1：输出高电平
//0：输出低电平
//Bit2 PWMn0_T：PWMn 通道 0 输出初始态选择位
//1：输出高电平
//0：输出低电平
//Bit1 PWMn1_P：PWMn 通道1 输出配置
//1：匹配点前输出值0，匹配点后输出1
//0：匹配点前输出值1，匹配点后输出0
//Bit0 PWMn0_P：PWMn 通道0 输出配置
//1：匹配点前输出值0，匹配点后输出1
//0：匹配点前输出值1，匹配点后输出0
//////////////////////////////////////////////////////////////
//PWMn_DT PWMn 死区输出控制寄存器

//////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////
#if(PWM00_POLARITY==PWM_POLARITY_H_L)
	PWM0_CH0_T_L;
	PWM0_CH0_H_L;
#else
	PWM0_CH0_T_H;
	PWM0_CH0_L_H;
#endif
#if(PWM10_POLARITY==PWM_POLARITY_H_L)
	PWM0_CH1_T_L;
	PWM0_CH1_H_L;
#else
	PWM0_CH1_T_H;
	PWM0_CH1_L_H;
#endif

    PWM0_DT=0;//PWM0死区延时
	//PWM0_C=_0001_0101;//关闭刹车功能//TMR1做时基//边沿对齐模式//PWM模式
	PWM0_C=_0001_0101;//关闭刹车功能//TMR1做时基//PWM0中心对齐模式//PWM模式

	TMR1L = 0;
	TMR1H = 0;

        TMR1_CYH = (UI08)((PWM0_PERIOD_VALUE-1) >> 8); // 设置在mcu_config.h文件
        TMR1_CYL = (UI08)(PWM0_PERIOD_VALUE-1);

	TMR1_C0=_0000_0000;// 禁止修改(关闭预分频8)

	PWM0_R0L=0;// 禁止修改(上电默认占空比0)
	PWM0_R0H=0;// 禁止修改(上电默认占空比0)

	PWM0_R1L = 0;// 禁止修改(上电默认占空比0)
	PWM0_R1H = 0;// 禁止修改(上电默认占空比0)

	TMR1_EN;        //启动TMR1
}
#endif////PWM0_CONFIG_EN
////////////////////////////////////////////////////////////////////////////////////////////////////////
#if(GCE_TIMER2_PWM1_EN)
/*************************************************
//名称        :PWM1_Init
//功能        :PWM1初始化
//入口参数    :无
//出口参数    :无
//当前版本    :V0.0
//编写:       :周智伟
//审核        :刘磊
//审核日期    :2021.5.13
//修改记录    :2021.5.14  V0.0初版发布
************************************************/
void PWM1_Init(void)
{
//////////////////////////////////////////////////////////////
//PWMn_IE PWM 中断使能寄存器（与CAPn_IE 寄存器复用）
//Bit7 保留,//Bit3 保留
//Bit6-4 STPn_IE：PWMn 刹车中断使能位
//Bit6==STP2_IE.Bit5==STP1_IE.Bit6==STP0_IE
//1：使能//0：禁止
//Bit2-0 PWMn_IE：PWMn 周期中断使能位
//Bit2==PWM2_IE.Bit1==PWM1_IE.Bit0==PWM0_IE
//1：使能//0：禁止
//////////////////////////////////////////////////////////////
//PWMn_IF PWM 中断标志寄存器（不CAPn_IF 寄存器复用）
//Bit7 保留,//Bit3 保留
//Bit6-4 STPn_IF：PWMn 刹车中断标志位
//Bit6==STP2_IF.Bit5==STP1_IF.Bit6==STP0_IF
//1：有PWMn 刹车中断请求//0：无PWMn 刹车中断请求
//Bit2-0 PWMn_IF：PWMn 周期中断标志位
//Bit2==PWM2_IF.Bit1==PWM1_IF.Bit0==PWM0_IF
//1：有PWMn 周期中断请求//0：无PWMn 周期中断请求
//////////////////////////////////////////////////////////////
//PWMn_C PWMn 控制寄存器（与CAPn_C 寄存器复用）
//Bit7-6 PWMn_SPS<1:0>：PWMn 刹车模式选择位（刹车后PWM 模式关闭，需要软件启动，
//清除STP_IF 需要先将 PWMn_SPS 清零，STP_IF 清除完成后，可再次使能对应模式）
//11：软件刹车（写“11”立即迕入刹车状态）
//10：保留
//01：STOP 复用端口输入低电平刹车
//00：关闭刹车功能
//Bit5-4 PWM_MD<1:0>
//11：保留//10：保留
//01：中心对齐模式
//00：边沿对齐模式
//Bit3-2 PWMn_TBS<1:0>：PWMn 工作时基选择位
//11：选择TMR3
//10：选择TMR2
//01：选择TMR1
//00：选择TMR0
//Bit1-0 PWMn_MOD<1:0>：PWMn 模式选择位
//11：保留//10：保留
//01：PWM模式
//00：关闭
//////////////////////////////////////////////////////////////
//PWMn_R0L PWMn 匹配点寄存器低8 位（与CAPn_DL 寄存器复用）写入先高后低
//PWMn_R0H PWMn 匹配点寄存器高8 位（与CAPn_DH 寄存器复用）
//PWMn_R1L PWMn 匹配点寄存器低8 位, 写入先高后低
//PWMn_R1H PWMn 匹配点寄存器高8 位
//////////////////////////////////////////////////////////////
//PWMn_OC PWMn 输出控制寄存器
//Bit7 保留
//Bit6-4 PWMn_REX：PWMn 平均占空比扩展位
//Bit3 PWMn1_T：PWMn 通道 1 输出初始态选择位
//1：输出高电平
//0：输出低电平
//Bit2 PWMn0_T：PWMn 通道 0 输出初始态选择位
//1：输出高电平
//0：输出低电平
//Bit1 PWMn1_P：PWMn 通道1 输出配置
//1：匹配点前输出值0，匹配点后输出1
//0：匹配点前输出值1，匹配点后输出0
//Bit0 PWMn0_P：PWMn 通道0 输出配置
//1：匹配点前输出值0，匹配点后输出1
//0：匹配点前输出值1，匹配点后输出0
//////////////////////////////////////////////////////////////
//PWMn_DT PWMn 死区输出控制寄存器

//////////////////////////////////////////////////////////////
    UI16 time_val = 0;
//////////////////////////////////////////////////////////////
#if(PWM01_POLARITY==PWM_POLARITY_H_L)
	PWM1_CH0_T_L;
	PWM1_CH0_L_H;
#else
	PWM1_CH0_T_H;
	PWM1_CH0_H_L;
#endif

#if(PWM11_POLARITY==PWM_POLARITY_H_L)
	PWM1_CH1_T_L;
	PWM1_CH1_L_H;
#else
	PWM1_CH1_T_H;
	PWM1_CH1_H_L;
#endif
	PWM1_DT=0;//死区延时
	PWM1_C=_0001_1001;//关闭刹车功能//TMR2做时基//PWM0中心对齐模式//PWM模式

	TMR2L = 0x00;
	TMR2H = 0x00;

	time_val = (UI16)(((((SYS_CLK_VALUE >> 3) / 1000) * PWM1_FREQ_VALUE)  / 1000)-1); // 设置在mcu_config.h文件
	TMR2_CYL = (UI08)(time_val >> 8);
	TMR2_CYH = (UI08)(time_val);

	TMR2_C0=_0100_0111;        //固定选择系统时钟8M//预分频8分频//后分频8分频//1mS

	PWM1_R0L=(UI08)((time_val/4) >> 8);
	PWM1_R0H=(UI08)((time_val/4));

	PWM1_R1L = (UI08)((time_val/4) >> 8);
	PWM1_R1H = (UI08)((time_val/4));

	TMR2_EN;        //启动TMR2
}
#endif///GCE_TIMER2_PWM1_EN
#if(GCE_LOWPOWER_EN)
void          _nop_     (void);
void MCU_Enter_Sleep(void)
{
//PCON 低功耗控制寄存器
//PCON_PR<3:0> ― ― IDLE SLEEP
//Bit7-4 PCON_PR<3:0>：PCON 解锁字
//W：写入5H 解锁，写入其他值锁定
//R：锁定状态读出为0H，解锁状态读出为1H
//Bit3-2 保留
//Bit1 IDLE：IDLE 模式使能位
//1：迕入IDLE 模式（仅在PCON_PR 解锁状态下，对PCON 寄存器写02H 可置1）
//0：退出IDLE 模式（写0 无效，唤醒后硬件自劢清0）
//Bit0 SLEEP：SLEEP 模式使能位
//1：迕入SLEEP 模式（仅在PCON_PR 解锁状态下，对PCON 寄存器写01H 可置1）
//0：退出SLEEP 模式（写0 无效，唤醒后硬件自劢清0）

//CLK_LP 时钟低功耗控制寄存器
//Bit7-5 保留
//Bit4 CLK_LEN：SLEEP 模式下系统时钟源使能位
//1：系统时钟源在SLEEP 模式下保持工作
//0：系统时钟源在SLEEP 模式下关闭
//Bit3-1 保留
//Bit0 FLT_BPS：系统时钟滤波器旁路控制位
//1：系统时钟滤波器关闭（旁路）
//0：系统时钟滤波器使能

	CLK_LP=_0000_0000;//0：系统时钟源在SLEEP 模式下关闭
	WDT_C=_0011_0000|WDT_TIME_2560mS;//配置软件关闭WDT//内部低频时钟LRC(规格书精度为+/-3%)
	_nop_();
	_nop_();
	PCON = 0x50;
	PCON = 0x01;
	PCON = 0xA0;
	//MCU进入SLEEP模式
	_nop_();
	_nop_();
#if(!GCE_DEBUG)
	WatchDog_Init();
#endif
}
#endif///GCE_LOWPOWER_EN
/////////////////////////////////////////////////
#if(GCE_LVD_EN)
//******************************************************************************
// 函数名称 : LVD_Init
// 功能说明 : 低电压检测初始化
// 入口参数 : 无
// 出口参数 : 无
// 当前版本 : V0.0
// 编写人员 : 曾海更
// 审核人员 : 刘磊
// 审核日期 : 2021.5.13
// 修改记录 : 2021.5.13  V0.0初版发布
//******************************************************************************
void LVD_Init(void)
{
    // 一、LVD基本介绍
	// LVD用于监测VDD电压,也可对于LVDIN复用端口输入电压进行监测,
    // 被监测电压由低亍比较阈值产生 LVD 中断标志。

    // 二、配置LVD主要配置如下寄存器
    // 1.LVD_C LVD 控制寄存器

    // 三、寄存器详解与配置(以下有”用户配置“字样的寄存器可修改,否则不可修改)
    //--------------------------------------------------------------------------
    // LVD_C LVD 控制寄存器0,默认值_0000_0000
    // Bit7 LVD_EN：LVD 使能位
    //      0-关闭,1-使能
//Bit6 LVD_IM：LVD 中断模式选择位
//1：被监测电压由高亍比较阈值产生LVD 中断
//0：被监测电压由低亍比较阈值产生LVD 中断
//Bit5-4 保留
//Bit3 LVD_INS：被监测电压选择位
//1：LVDIN 复用管脚（比较阈值电压固定为0.5V）
//0：VDD
//Bit2-0 LVD_VS<2:0>：阈值电压选择位（仅用亍监测VDD）
//111：4.6V   110：4.2V   101：3.8V   100：3.4V
//011：3.0V   010：2.6V   001：2.2V   000：1.8V
    LVD_C =bit7|LVD_VOLT_VALUE; // 禁止修改// ：被监测电压选择位VDD//设置在mcu_config.h文件

    LVD_IF = 0; // 禁止修改(清中断标志位)
    AN_IE |= bit2; // 禁止修改(LVD中断使能)

    INT6_IF = 0; // 禁止修改(清中断向量标志位)
    INT6_IE = 0; // 禁止修改(0-关闭中断向量6, 1-打开中断向量6)
}
#endif//(GCE_LVD_EN)///
/*************************************************
//名称        :MCU_Initial
//功能        :MCU初始化
//入口参数    :无
//出口参数    :无
//当前版本    :V0.0
//编写:       :周智伟
//审核        :刘磊
//审核日期    :2021.5.11
//修改记录    :2021.5.12  V0.0初版发布
************************************************/
void MCU_Initial(void)
{
	GCE_GIE(0);
	Startup_Init();//上电初始化

	IO_Init();//先配置IO

	Timer0_Init();
//---------------------------------------
	#if(GCE_LVD_EN)
	LVD_Init();
	#endif
//---------------------------------------
//---------------------------------------
	#if(GCE_ADC_EN)
	ADC_Init();
	#endif
//---------------------------------------
//---------------------------------------
	#if(GCE_UART0_EN)
	UART0_Init();
	#endif
//---------------------------------------
//---------------------------------------
	#if(GCE_UART1_EN)
	UART1_Init();
	#endif
//---------------------------------------
//---------------------------------------
	#if(GCE_TIMER1_PWM0_EN)
	PWM0_Init();
	#endif
//---------------------------------------
//---------------------------------------
	#if(GCE_TIMER2_PWM1_EN)
	PWM1_Init();
	#endif
//---------------------------------------
//---------------------------------------
	#if(GCE_EXT0_EN)
	EXT0_Init();
	#endif
//---------------------------------------
//---------------------------------------
	#if(GCE_EXT1_EN)
	EXT1_Init();
	#endif
//---------------------------------------
	#if(!GCE_DEBUG)
	WatchDog_Init();
	#endif

	#if(GCE_PRIORITY_EN)
	Priority_Init();
	#endif
	#if(GCE_TK_EN)
	//TKInit();
	#endif

        EXV_Data_Init();
	Motor_Data_Init();

	I2C_Dat_Init();
  	GCE_GIE(1); //总中断使能请放在TKInit之后// Enable all interrupt
}

/******************* (C) COPYRIGHT 2021 GCE *****END OF FILE****/
